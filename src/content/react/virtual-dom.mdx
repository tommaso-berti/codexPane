# Virtual dom

## why frequent dom updates are slow
This slowness is made worse by the fact that most JavaScript frameworks update the DOM much more than they have to.
As an example, let’s say that you have a list that contains ten items. You check off the first item. Most JavaScript frameworks would rebuild the entire list. That’s ten times more work than necessary! Only one item changed, but the remaining nine get rebuilt exactly how they were before.

To address this problem, the people at React popularized something called the virtual DOM.

> **Note**
> Updating the real DOM triggers style recalculation, layout, and paint. Avoiding unnecessary nodes keeps these steps minimal.

### minimal example
~~~
<ul>
  {items.map((item, i) => (
    <li key={item.id}>
      <label>
        <input
          type="checkbox"
          checked={item.done}
          onChange={() => toggle(i)}
        />
        {item.text}
      </label>
    </li>
  ))}
</ul>
~~~

## virtual dom in react
In React, for every DOM object, there is a corresponding “virtual DOM object.” A virtual DOM object is a representation of a DOM object, like a lightweight copy.

Manipulating the DOM is slow. Manipulating the virtual DOM is much faster because nothing gets drawn onscreen. Think of manipulating the virtual DOM as editing a blueprint, as opposed to moving rooms in an actual house.

> **Tip**
> Treat renders as pure functions of props and state. React will reconcile the resulting virtual tree efficiently.

## how it works
When you render a JSX element, every single virtual DOM object gets updated. This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM can update so quickly.

Once the virtual DOM has been updated, then React compares the virtual DOM with a virtual DOM snapshot that was taken right before the update.
By comparing the new virtual DOM with a pre-update version, React figures out exactly which virtual DOM objects have changed. This process is called “diffing.”

Once React knows which virtual DOM objects have changed, then React updates those objects, and only those objects, on the real DOM. In our example from earlier, React would be smart enough to rebuild your one checked-off list-item and leave the rest of your list alone.

### reconciliation steps
virtual tree (after setState)
↓ diff
minimal patch list
↓ apply
real DOM updates

### keyed lists example
~~~
function TodoList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.text}</li>  {/* stable key is crucial */}
      ))}
    </ul>
  );
}
~~~

> **Attention**
> Avoid using array index as a key for re-ordered lists. It can cause unnecessary unmounts and re-mounts.

## summary
In summary, here’s what happens when you try to update the DOM in React:
* The entire virtual DOM gets updated.
* The virtual DOM gets compared to what it looked like before you updated it. React figures out which objects have changed.
* The changed objects, and the changed objects only, get updated on the real DOM.
* Changes on the real DOM cause the screen to change.

## Diffing playground
import DiffingDemo from "./components/virtual-dom/DiffingDemo.jsx"

<DiffingDemo />

> **Note**
> The playground simulates React’s idea of producing a minimal patch set by comparing previous and next arrays and showing which indices would update.
