# Redux middleware and thunks

## Middleware in redux
When an action is dispatched, it is immediately processed by a reducer, which updates the store accordingly. But when developing applications, we often want to perform asynchronous operations (such as making API calls) and update the state based on the results.

**Middleware in Redux**
Out of the box, Redux may meet most of your app’s state management needs. But every project is different, and so Redux provides some ways to customize its behavior. One of the ways we can customize Redux is by adding middleware.

As the name suggests, middleware is the code that runs in the middle—usually between framework receiving a request and producing a response. Middleware is a powerful tool for extending, modifying, or customizing a framework or library’s default behavior to meet an application’s specific needs.

In Redux, middleware runs between when an action is dispatched and when that action is passed along to the reducer. By this point, you’re familiar with the way data flows through Redux: actions are dispatched to the store, where they are processed by reducers that produce a new state; that new state becomes accessible to all the components that reference it, causing those components to update.

Middleware intercepts actions after they are dispatched and before they are passed along to the reducer. Some common tasks that middleware performs include logging, caching, adding auth tokens to request headers, crash reporting, routing, and making asynchronous requests for data. You can add any of these functionalities to your apps by using popular open-source middleware. Of course, you can also write your own middleware to solve problems that are specific to your application and its architecture.

To make asynchronous requests in our recipe app, we’re using a Redux Toolkit utility function called `createAsyncThunk()` and the `extraReducers` option you can pass to the `createSlice` function. In subsequent exercises, we will walk through how `createAsyncThunk()` uses middleware and thunks to make asynchronous requests possible; for now, you should just understand where middleware sits in Redux’s data flow.

## Write your own middleware
To add a middleware to our project, we use Redux’s `applyMiddleware` function like so.
~~~
import { createStore, applyMiddleware } from 'redux';
import { middleware1, middleware2, middleware3 } from './exampleMiddlewares';
import { exampleReducer } from './exampleReducer';
import { initialState} from './initialState';

const store = createStore(
  exampleReducer,
  initialState,
  applyMiddleware(
    middleware1,
    middleware2,
    middleware3
  )
);
~~~

Once middleware has been added to a Redux project, calls to `dispatch` are actually calls to the middleware pipeline (the chain of all added middlewares). This means that any actions we dispatch will be passed from middleware to middleware before they hit an app’s reducers.

Middlewares must conform to a specific, nested function structure in order to work as part of the pipeline (this nested structure is also called a higher-order function, if you’d like to read more). That structure looks like this:
~~~
const exampleMiddleware = storeAPI => next => action => {
  // do stuff here
  return next(action);  // pass the action on to the next middleware in the pipeline
}
~~~

Each middleware has access to the `storeAPI` (which consists of the `dispatch` and `getState` functions), as well as the `next` middleware in the pipeline, and the `action` that is to be dispatched. The body of the middleware function performs the middleware’s specific task before calling the next middleware in the pipeline with the current action (note that if the middleware is the last in the pipeline, then `next` is `storeAPI.dispatch` so calling `next(action)` is the same as dispatching the action to the store).

**Example of a custom middleware**
~~~
import { createStore, applyMiddleware } from 'redux';

const messageReducer = (state = '', action) => {
  if (action.type === 'NEW_MESSAGE') {
    return action.payload;
  } else {
    return state;
  }
}

// Paste the logger function here.
const logger = storeAPI => next => action => {
  console.log(storeAPI.getState())
  const nextState = next(action)
  console.log(nextState)
  return nextState;
};

const store = createStore(messageReducer, '', applyMiddleware(logger));

store.dispatch({
  type: 'NEW_MESSAGE',
  payload: 'I WROTE A MIDDLEWARE'
});
~~~

## Introduction to thunks
One of the most flexible and popular ways to add asynchronous functionality to Redux involves using thunks. A thunk is a higher-order function that wraps the computation we want to perform later. For example, this `add()` function returns a thunk that will perform `x+y` when called.
~~~
const add = (x,y) => {
  return () => {
    return x + y;
  }
}
~~~

Note that calling `add()` does not cause the addition to happen – it merely returns a function that will perform the addition when called. To perform the addition, we must call `delayedAddition()`.
~~~
const delayedAddition = add(2,2)
delayedAddition() // => 4
~~~

Example:
~~~
const remindMeTo = task => {
  return `Remember to ${task}!!!`;
}

const remindMeLater = (task) => {
  return () => {
   return remindMeTo(task)
  }
}

console.log(remindMeTo('call mom'))
const reminder = remindMeLater('get groceries')
console.log(reminder())
~~~

## Promise lifecycle actions
This pattern is so common that Redux Toolkit provides a neat abstraction, `createAsyncThunk`, for including promise lifecycle actions in your Redux apps.

## Create async thunk
`createAsyncThunk()` is a function with two parameters, an action type string, and an asynchronous callback, that generates a thunk action creator that will run the provided callback and automatically dispatch promise lifecycle actions as appropriate so that you don’t have to dispatch pending/fulfilled/rejected actions by hand.
~~~
import { createAsyncThunk } from '@reduxjs/toolkit';
~~~

Next, you’ll need to call `createAsyncThunk()`, passing two arguments. The first is a string representing the asynchronous action’s type. Conventionally, type strings take the form `"resourceType/actionName"`. In this case, since we are getting an individual user by their `id`, our action type will be `users/fetchUserById`. The second argument to `createAsyncThunk` is the payload creator: an asynchronous function that returns a promise resolving to the result of an asynchronous operation. Here is `fetchUserById` rewritten using `createAsyncThunk`:
~~~
import { createAsyncThunk } from '@reduxjs/toolkit'
import { fetchUser } from './api'
const fetchUserById = createAsyncThunk(
  'users/fetchUserById', // action type
  async (arg, thunkAPI) => { // payload creator
    const response = await fetchUser(arg);
    return response.json();
  }
)
~~~

There are a few things worth highlighting here. First, observe that the payload creator receives two arguments—`arg` and `thunkAPI`. We will elaborate on those in the next exercise. Second, note that the payload creator we provided doesn’t dispatch any actions at all. It just returns the result of an asynchronous operation.

The first argument, `arg`, will be equal to the first argument passed to the thunk action creator itself. For example, if we call `fetchUserById(7)`, then inside the payload creator, `arg` will be equal to 7.

Since the payload creator only receives the first argument passed to the thunk action creator, you’ll want to bundle multiple arguments into a single object. For example, say we want to search our app’s users by first and last name. If the thunk action creator is called `searchUsers`, we would call it like this: `searchUsers({firstName: 'Ada', lastName: 'Lovelace'})`.
~~~
const searchUsers = createAsyncThunk(
    'users/searchUsers',
    async ({ firstName, lastName}, thunkAPI) => {
        // perform the asynchronous search request here
    }
)
~~~

If your thunk requires no arguments, you can just call the action creator without it, and the `arg` argument will be undefined.

In the event the thunk requires only one param (for example, fetching a specific resource by `id`) you should name that first param semantically. Here’s the `fetchUserById` example from the last exercise, with the `arg` parameter semantically renamed to `userId`.
~~~
import { createAsyncThunk } from '@reduxjs/toolkit'
import { fetchUser } from './api'
const fetchUserById = createAsyncThunk(
    'users/fetchUserById', // action type
    async (userId, thunkAPI) => { // payload creator
        const response = await fetchUser(userId)
        return response.data
    }
)
~~~

The payload creator’s second argument, `thunkAPI`, is an object containing several useful methods, including the store’s `dispatch` and `getState`.

## Actions generated by create asyncthunk
As you know, `createAsyncThunk` takes care of dispatching actions for each of the promise lifecycle states: pending, fulfilled, and rejected. But what exactly do these actions look like?

Building off the action type string you pass to it, `createAsyncThunk` produces an action type for each promise lifecycle state. If you pass the action type string `'resourceType/actionType'` to `createAsyncThunk`, it will produce these three action types:
* `'resourceType/actionType/pending'`
* `'resourceType/actionType/fulfilled'`
* `'resourceType/actionType/rejected'`

~~~
import { createAsyncThunk } from '@reduxjs/toolkit'
import { fetchUser } from './api'

const fetchUserById = createAsyncThunk(
  'users/fetchUserById', // action type
  async (userId, thunkAPI) => { // payload creator
    const response = await fetchUser(userId)
    return response.data
  }
)
~~~

When you pass `createAsyncThunk` the action type string `'users/fetchUserById'`, `createAsyncThunk` produces these three action types:
* `'users/fetchUserById/pending'`
* `'users/fetchUserById/fulfilled'`
* `'users/fetchUserById/rejected'`

If you need to access the individual pending/fulfilled/rejected action creators, you can reference them like this:
* `fetchUserById.pending`
* `fetchUserById.fulfilled`
* `fetchUserById.rejected`

You will have to handle these action types in your reducers if you want to reflect these promise lifecycle states in your app.

## Using createslice with async action creators
How can we account for these promise lifecycle action types in our user slice? This is exactly the problem that `extraReducers`, an optional property on the configuration object passed to `createSlice()`, was designed to solve. `extraReducers` allows `createSlice()` to respond to action types generated elsewhere. To make the user’s slice respond to promise lifecycle action types, we pass them to `createSlice()` in the `extraReducers` property.

Note that in addition to using the `extraReducers` property, we also added some extra fields to our state object: a boolean, `isLoading`, which will be true when a request is pending, and otherwise false, and a boolean `hasError`, which we will set to `true` if our request to fetch a user is rejected. These additions allow us to track promise lifecycle states so that we can create satisfying and informative user interfaces when the promise is either `pending` or `rejected`. When the promise is `fulfilled` these are set to `false`, and the user data is added to the state.
~~~
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    users:  [],
    isLoading: false,
    hasError: false
  },
  reducers: {
    addUser: (state, action) => {
      state.users.push(action.payload)
    }
  },
  extraReducers: {
    [fetchUserById.pending]: (state, action) => {
      state.isLoading = true;
      state.hasError = false;
    },
    [fetchUserById.fulfilled]: (state, action) => {
      state.users.push(action.payload);
      state.isLoading = false;
      state.hasError = false;
    },
    [fetchUserById.rejected]: (state, action) => {
      state.isLoading = false;
      state.hasError = true;
    }
  }
})
~~~

## Middleware pipeline playground
import MiddlewarePlayground from "./components/redux-middleware-and-thunks/MiddlewarePlayground.jsx"

<MiddlewarePlayground />

> Tip: Open the browser console to see the logger middleware print previous and next state around each thunk lifecycle action.