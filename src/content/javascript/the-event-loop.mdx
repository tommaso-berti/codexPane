# The Event Loop

## What is synchronous code
Synchronous code executes in sequential order — it starts with the code at the top of the file and executes line by line until the end. Each line **blocks** the next until it finishes.

## What is asynchronous code
Asynchronous code can be scheduled to run later or in parallel with currently running code. It is **non blocking** and often relies on multiple **threads** at the platform level (e.g., web browser or Node) to perform tasks concurrently. More threads generally allow more tasks to run at once.

**Note:** JavaScript itself is **single threaded**, but browsers and Node expose asynchronous **APIs** plus an **event loop** that lets JS coordinate async work.

## Asynchronous callbacks
A callback that runs after an external event or timer completes.

~~~js
easterEgg.addEventListener('click', () => {
  console.log('Up, Up, Down, Down, Left, Right, Left, Right, B, A');
});
// The function runs only after the element is clicked.
~~~

## Set timeout
Schedules a function to run **after at least** the given delay (ms).

~~~js
setTimeout(() => {
  console.log('Delay the printing of this string, please.');
}, 1000); // ≈ 1 second
~~~

**Tip:** The delay is a **minimum**; the callback runs when the call stack is free.

## Set interval
Repeats a function every `n` ms until cleared.

~~~js
const id = setInterval(() => {
  alert('Are you paying attention???');
}, 300000); // 5 minutes

// clearInterval(id) to stop
~~~

## Concurrency model and event loop in javascript
Even though JavaScript executes on a single thread, the **event loop** allows non blocking behavior:

~~~js
console.log("I’m learning about");
setTimeout(() => { console.log("Event Loop"); }, 2000);
console.log("the");
// Order: "I’m learning about" → "the" → (after ~2s) "Event Loop"
~~~

## What is the event loop
A scheduling system that coordinates:
- JavaScript engine (heap, call stack)
- Platform APIs (web or Node)
- Queues of pending work (tasks/events)

It moves ready-to-run callbacks from queues to the call stack when the stack is empty.

## Components of the event loop
- **Memory heap** — where objects live.
- **Call stack** — where the currently executing function frame sits.
- **Event queue** — FIFO list of pending callbacks (tasks).
- **Event loop** — the coordinator that enqueues tasks onto the stack when it’s clear.
- **Node or web apis** — timers, network, DOM events, etc.

**Copy friendly diagram (ASCII):**
~~~txt
[ Web/Node APIs ] --(events)--> [ Event queue ] --(when stack empty)--> [ Call stack ]
         ^                                                                   |
         |------------------------ scheduled callbacks ----------------------|
~~~

**Note:** The diagram above uses only ASCII characters so it can be copied reliably in any editor.

## Heap
A block of memory holding objects and values currently in use.

~~~js
const cat = {
  name: "Jupiter"
};

const pets = ["Jupiter", "Moshi", "Hercules"];
// cat and pets live in the heap; fixed-size references to them live on the stack.
~~~

## The call stack
Tracks the **current execution context**. Calling a function pushes a frame; returning pops it. LIFO (last in, first out).

~~~js
function foo() {
  return function bar() {
    return function baz() {
      return 'I love CodeCademy';
    }
  }
}
console.log(foo()()()); // nested frames push/pop
~~~

**Note:** The global execution context is created first; each function call creates its own execution context.

## The event queue
FIFO list of callbacks waiting to run. No code executes here; it only **stores** tasks until the stack is clear.

Process:
1. Event loop checks if the stack is empty.
2. If empty and the queue has tasks, it moves the first task to the stack.
3. Repeat.

## The event loop in action
~~~js
console.log("This is the first line of code in app.js.");

function usingsetTimeout() {
  console.log("I'm going to be queued in the Event Loop.");
}

setTimeout(usingsetTimeout, 3000);

console.log("This is the last line of code in app.js.");
~~~

Step by step:
- First `console.log` runs and pops.
- `setTimeout` schedules via a web api; after ~3s its callback enters the **event queue**.
- Second `console.log` runs and pops.
- When the stack is empty, the event loop moves the queued callback to the stack; it logs and returns.

## Example
~~~js
const shopForBeans = () => {
  return new Promise((resolve, reject) => {
    const beanTypes = ['kidney', 'fava', 'pinto', 'black', 'garbanzo'];
    setTimeout(() => {
      let randomIndex = Math.floor(Math.random() * beanTypes.length);
      let beanType = beanTypes[randomIndex];
      console.log(`2. I bought ${beanType} beans because they were on sale.`);
      resolve(beanType);
    }, 1000);
  });
}

async function getBeans() {
  console.log(`1. Heading to the store to buy beans...`);
  let value = await shopForBeans();
  console.log(`3. Great! I'm making ${value} beans for dinner tonight!`);
}

getBeans();
console.log("Describe what happens with this `console.log()` statement as well.");
~~~

Expected order:
1. `Heading to the store to buy beans...`
2. `Describe what happens with this console.log() statement as well.`
3. `I bought <type> beans because they were on sale.`
4. `Great! I'm making <type> beans for dinner tonight!`

## Microtasks and macrotasks
**Promises** (and `queueMicrotask`) queue **microtasks**, which run **before** timer or IO callbacks (often called **macrotasks**) once the call stack is clear.

~~~js
console.log('A');
setTimeout(() => console.log('timeout'), 0); // macrotask
Promise.resolve().then(() => console.log('microtask')); // microtask
console.log('B');
// Order: A, B, microtask, timeout
~~~

**Attention:** A long-running synchronous loop blocks *everything*, preventing even microtasks from running until it finishes.

## Event loop playground
import EventLoopPlayground from "./components/the-event-loop/EventLoopPlayground.jsx"

<EventLoopPlayground />

---

## Memory management
In other languages like C or C++, you manually `new`/`delete` memory. In JavaScript, the engine handles allocation and reclamation for you. The main problems you encounter are **memory leaks**—memory that should be released but remains referenced.

**Note:** JavaScript has two data structures for memory:
- The **heap**
- The **stack**

When you assign values to variables, the engine decides whether the value is a **primitive** or a **reference value**, which determines if it is stored in the stack or the heap.

## The stack and the heap
**The stack** is used for static storage where the size is known. It holds:
- Primitive values,
- **References** to non-primitive values,
- Function call frames.

**The heap** provides dynamic storage for data without fixed size (objects, functions). We keep track of where to find them in the unstructured heap using fixed-size references on the stack.

~~~js
const cat = { name: "Jupiter" };
const pets = ["Jupiter", "Moshi", "Hercules"];
// cat and pets are in the heap; references to them are on the stack.
~~~

~~~js
let object = new Object();
let object2 = object;
object.greeting = "Hello, world";

console.log(object2); // { greeting: 'Hello, world' }
~~~

In the example, `object` and `object2` are different variables (stack), but both point to the **same** heap object.

~~~js
let str = "Hi";
let str2 = str;
// str and str2 are two separate primitives on the stack (copy by value)
~~~

**Tip:** Mutating an object via any reference affects the single underlying heap object.

## Memory life cycle
Three parts to consider:
- **Memory allocation** — values are declared and stored.
- **Memory in use** — values are read or rewritten.
- **Releasing memory** — values no longer in use get removed.

Allocation can happen via:
- Regular variable assignment,
- Assigning properties to an object,
- Declaring callable functions,
- Calling functions (which pushes a **function frame** onto the stack).

During function execution, locals allocate stack space; new objects allocate heap space and are referenced from the frame. When a function returns, its frame is popped and its stack memory is deallocated. Heap objects that become unreachable are then eligible for garbage collection.

~~~js
let aaliyah = { name: "Aaliyah" };

function nameObjectModification(obj, name) {
  obj.name = name;
  return obj;
}

let sarah = nameObjectModification(aaliyah, "Sarah");

console.log(aaliyah); // { name: 'Sarah' }
console.log(sarah);   // { name: 'Sarah' }
~~~

Objects are passed by **reference value copy** (the reference is copied). If you modify the object inside a function, the original is modified because both variables reference the same heap object.

## Garbage collection
Garbage collection clears memory that is no longer needed. Engines use two key algorithms:

### Reference counting
Tracks how many references point to an object.

~~~js
let obj = new Object(); // count = 1
let obj2 = obj;         // count = 2
obj2 = "string";        // obj count returns to 1
~~~

If the count drops to **zero**, the object can be reclaimed.

~~~js
let monument = { name: "Eiffel Tower" };
monument = "Golden Gate Bridge"; // previous object becomes collectible if no other refs
~~~

**Attention:** Pure reference counting struggles with **circular references**.

### Mark and sweep
Runs periodically from the root (global object), **marks** reachable values by traversing references, then **sweeps** unmarked ones. This handles cycles correctly and is what most modern engines use.

## Memory leaks
When memory that is no longer needed persists, it’s a **memory leak**. Causes include:

## Messy closures
Long-lived closures over large objects keep them alive.

~~~js
function bigObjMaker() {
  const bigObj = {};
  return (key, val) => {
    bigObj[key] = val;
    console.log(bigObj);
  }
}
let bigMemoryUser = bigObjMaker();

Array(1000).fill(1).map((x,i) => {
  bigMemoryUser(i, i);
});
~~~

`bigObj` remains reachable through the closure and can grow indefinitely.

## Dangling timers and event listeners
Intervals, timeouts, or event handlers can hold references and prevent collection.

~~~js
function cb() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  }
}

let intervalID = setInterval(cb(), 1000);
// later...
clearInterval(intervalID);
~~~

Anonymous listeners also capture outer values:

~~~js
const lotsOfMemory = "Imagine this is a value that uses a lot of memory";

document.addEventListener('scroll', function() {
  cb(lotsOfMemory);
});
~~~

## Circular references
Objects that reference each other can defeat reference counting (though not mark-and-sweep).

~~~js
let first = new Object();
let second = new Object();

first.aProperty = second;
second.anotherProperty = first;
~~~

## Declaring variables on the global object
Accidentally creating globals keeps them alive for the lifetime of the page or process.

~~~js
function helloWorld() {
  // Missing let/const/var — becomes a global binding in sloppy mode
  greeting = "Hello world";
  // Also leaks to global this in sloppy mode
  this.greeting2 = "Goodbye!";
}
helloWorld();
~~~

**Tip:** Always use `let`/`const` and enable **strict mode** to avoid accidental globals.

## Out of memory errors
When memory grows without bound (e.g., leaks), processes can crash or slow down.

Example Node error:
~~~txt
==== JS stack trace =========================================
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory
~~~

Increasing Node’s heap can mask the issue, but the better fix is to find and remove the leak. In browsers, tabs may crash when memory is exhausted.

## Memory behavior and performance
Garbage collection frequency and pauses affect performance. High **object churn** can trigger frequent GCs and jank. Techniques like **object pooling** in hot paths can reduce allocations and GC pressure.

---

## Memory leaks playground
import MemoryGraphDemo from "./components/the-event-loop/MemoryGraphDemo.jsx"

<MemoryGraphDemo />