# Selectors

> **Note:** Selector specificity matters. Rough guide (from low → high): universal `*` < tag `p` < class/attribute/pseudo class `.btn`, `[href]`, `:hover` < ID `#app` < inline styles. When rules tie, the later one in the stylesheet wins.

## Tag selector

Selects all elements by tag name.

~~~css
p {
  font-family: Verdana;
}
~~~

## Universal selector

Targets every element. Useful for resets—use sparingly.

~~~css
* {
  font-family: Verdana;
}
~~~

> **Tip:** Common reset:
> ~~~css
> *, *::before, *::after { box-sizing: border-box; }
> ~~~

## Class selector

Uses `.` before the class name. Class beats tag by specificity.

~~~css
.brand {
  /* ... */
}
~~~

## ID selector

IDs are unique per page and outrank classes.

~~~css
#large-title {
  /* ... */
}
~~~

## Attribute selectors

Select based on attributes and values.

- Basic presence:
~~~css
[href] { color: magenta; }
  ~~~
- Match fragments with `*=`:
~~~html
<img src="/images/seasons/cold/winter.jpg" alt="">
<img src="/images/seasons/warm/summer.jpg" alt="">
  ~~~
~~~css
img[src*="winter"] { height: 50px; }
img[src*="summer"] { height: 100px; }
  ~~~

> **Note:** Other operators: `^=` (starts with), `$=` (ends with), `~=` (contains word), `|=` (lang-prefix).

## Pseudo class selectors

Represent transient states like interaction, history, or position.

~~~css
p:hover {
  background-color: lime;
}
~~~

Links often use this order so interactive states override static ones:

~~~css
/* order: :link → :visited → :hover → :active */
a:link { color: blue; }
a:visited { color: purple; }
a:hover { color: orange; }
a:active { color: red; }

a { cursor: pointer; } /* make the pointer hand on hover */
~~~

> **Tip:** Common pseudo classes: `:focus`, `:focus-visible`, `:disabled`, `:checked`, `:nth-child(n)`, `:not(...)`.

## Descendant and child combinators

**Chained/descendant** selectors apply to elements inside another selector:

~~~css
p { color: blue; }
.main p { color: red; }  /* only <p> inside .main are red */
~~~

**Direct child** uses `>` and ignores deeper descendants:

~~~css
div img { /* any descendant <img> inside a <div> */ }
div > img { /* only immediate child <img> of a <div> */ }
~~~

## Grouping selectors

Apply the same declarations to multiple selectors by separating with commas.

~~~css
h1,
.menu {
  font-family: Georgia;
}
~~~

## Sibling combinators and pseudo elements

Adjacent siblings `+` select the next element that shares the same parent. Pseudo elements create generated content.

~~~css
.breadcrumb li + li::before {
  padding: 10px;
  content: ">";
}
~~~

- `li + li` selects an `li` that immediately follows another `li`.
- `::before` inserts generated content before the element’s content.

> **Attention:** Prefer utility classes or low-specificity selectors for scalability; avoid over-qualifying selectors (e.g., `ul.nav li a.button`) which increases specificity and coupling.